---
title: "Static Code Analysis"
date: 2018-09-03T19:48:11+02:00
---

CogniCrypt's static analysis automatically runs on the code within Eclipse. The static analysis is based on `CrySL rules` that specify the *correct* use of an application programming interface (API). `CrySL` is a domain-specific language that allows to specify usage patterns of APIs. The static analysis reports any deviations from the usage pattern defined within the rules. 

While the `CrySL` rules are adjustable, a user of CogniCrypt is not expected to change the rules of CogniCrypt. 

## Eclipse Error Markers and their Meanings

CogniCrypt generates errors markes when the analysis detects incorrect and insecure parts of code. CogniCrypt displays error markers within the Eclipse IDE to warn the developer about insecure code. The error markers are associated to the respective line in the editor the errors is located at. 

There are various different error types that CogniCrypt reports. Below, we distinguish the error types based on the warning the error marker reports.

* `"MD5 should be any of {SHA-256, SHA-384, SHA-512}"` is a **Constraint Error**: the static analysis detects an incorrect `String` (or `int`) to flow as argument to a method call. CogniCrypt automatically suggest alternatives to fix the issue. The error message describes that `MD5` should be replaced by and of the other `String` elements.  

* `"Unexpected call to method reset. Expect a call to one of the following methods digest,update"` marks a **Typestate Error**. The sequence of object calls made on an object is not according to its `CrySL` specification.

* `"Operation with Cipher object not completed. Expected call to update, doFinal."` marks an **Incomplete Operation Error**. An incomplete operation errors appears, when a call on an object is missing and the object is garbage collected without having properly used. A typically example for such an error is a missing call to `close` on a `FileWriter`.

* `"Variable keyBytes was not properly randomized"` is called a **Required Predicate Error**. Such an error is reported when the analysis infers that the combination of using *several* object is incorrect. The error message reports that the developer uses a variable `keyBytes` (containing some `byte[]`) for some cryptographic operation. The correct specification of the API requires that the `byte` array has been previously `randomized` (wich means correctly generate by some API).

## CrySL Rules for the JCA
CogniCrypt ships with a pre-defined set of `CrySL` rules. The standard rule set covers the correct specification of most classes of the [Java Cryptographic Architecture (JCA)](https://docs.oracle.com/javase/8/docs/technotes/guides/security/crypto/CryptoSpec.html). The JCA offers various cryptographic services. In the following, we describe these services with their respective classes and briefly summarize important usage constraints. All mentioned classes are defined in the packages `javax.crypto` and `java.security` of the JCA. 

The rule set is also [publicly available](https://github.com/CROSSINGTUD/Crypto-API-Rules) .The definition of the `CrySL` rules are found in the files ending in `.cryptsl` named with the respective class name.

* **Asymmetric Key Generation**: 
Asymmetric and symmetric cryptography requires different key formats. Asymmetric cryptography uses pairs of public and private keys. While one of the keys encrypts plaintexts to ciphertexts, the second key decrypts the ciphertext. The JCA models a key pair as class `KeyPair` and are generated by `KeyPairGenerator`. 

* **Symmetric Key Generation**:
Symmetric cryptography uses the same key for encryption and decryption. The JCA models symmetric keys as type `SecretKey`, generated by a `SecretKeyFactory` or `KeyGenerator`. The `SecretKeyFactory` also enables password-based cryptography using `PBEParameterSpec` or `PBEKeySpec`. 

* **Signing and Verification of Data**:
The class `Signature` of the JCA allows one to digitally sign data and verify a signature based on a private/public key pair. A `Signature` requires the key pair to be correctly generated, hence the rule for `Signature` requires a predicate from the asymmetric-key generation task.

* **Generation of Initialization Vectors**:
Initialization vectors (IVs) are used to add entropy to ciphertexts of encryptions. An IV must have enough randomness and must be properly generated. The JCA class `IvParameterSpec` wraps a byte array as an IV and it is required for the array to be randomized by `SecureRandom`. The `CrySL` rule for `IvParameterSpec` requires a predicate `randomized`.

* **Encryption and Decryption**
The key component of the JCA is represented by the class `Cipher`, which implements functionality to encrypt or decrypt data. Depending on the used algorithms, modes and paddings must be selected and keys and initialization vectors must be properly generated. Hence, the complete `CrySL` rule for `Cipher` requires many other cryptographic services to be executed securely earlier and list them in its respective `REQUIRES` clause.

* **Hashing & MACs**Â´:
There are two forms of cryptographic hash functions. A MAC is an authenticated hash that requires a symmetric keys, but there are also keyless hash functions such as MD5 or SHA-256. The JCA's class `Mac` implements functionality for mac-ing, while keyless hashes are computed by `MessageDigest`. 

* **Persisting Keys**:
Securely storing key material is an important cryptographic task for confidentiality and integrity of the encrypted data. The JCA class `KeyStore` supports  developers in this task and stores the key material.

* **Cryptographically Secure Random-Number Generation**: 
Randomness is vital in all aspects of cryptography. Java offers cryptographically secure pseudo-random number generators through `SecureRandom`. As discussed for `PBEKeySpec`, `SecureRandom` often acts as a helper and therefore many rules list the `randomized` predicate in their own `REQUIRES` section.
